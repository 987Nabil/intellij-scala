package org.jetbrains.plugins.scala.caches

import org.jetbrains.plugins.scala.caches.stats.Tracer

import java.util.concurrent.ConcurrentHashMap

private class CacheWithoutModificationCountN[T <: Product, R](id: String, name: String, wrapper: ValueWrapper, cleanupScheduler: CleanupScheduler) {
  // Code generated by @CachedWithoutModificationCount macro annotation, method with parameters

  private[this] val map = new ConcurrentHashMap[T, ValueWrapper.Reference[R]]()

  cleanupScheduler.subscribe { () =>
    map.clear()
  }

  def apply(key: T)(f: => R): R = {
    val reference = {
      val fromMap = map.get(key)
      if (fromMap != null) fromMap else null
    }
    val tracer = Tracer(id, name)
    tracer.invocation()
    val resultFromCache = if (reference == null) null.asInstanceOf[R] else reference.get()
    if (resultFromCache == null) {
      tracer.calculationStart()
      val computedValue = try {
        f
      } finally {
        tracer.calculationEnd()
      }
      assert(computedValue != null, "Cached function should never return null")
      map.put(key, wrapper.wrap(computedValue))
      computedValue
    } else {
      resultFromCache
    }
  }

/*
@CachedWithoutModificationCount(ValueWrapper.SofterReference, cleanupScheduler)
def foo(x: Int): String = "Foo"

private val org$example$Example$foo$map = new java.util.concurrent.ConcurrentHashMap[Int, _root_.com.intellij.util.SofterReference[String]]();
cleanupScheduler.asInstanceOf[_root_.org.jetbrains.plugins.scala.caches.CleanupScheduler].subscribe((() => org$example$Example$foo$map.clear()));
def foo(x: Int): String = {
  var org$example$Example$foo = {
    val fromMap = org$example$Example$foo$map.get(x);
    if (fromMap.$bang$eq(null))
      fromMap
    else
      null.asInstanceOf[_root_.com.intellij.util.SofterReference[String]]
  };
  val org$example$Example$foo$$tracer = _root_.org.jetbrains.plugins.scala.caches.stats.Tracer("org$example$Example$foo$cacheKey", "Example.foo");
  org$example$Example$foo$$tracer.invocation();
  val resultFromCache = if (org$example$Example$foo.$eq$eq(null))
    null
  else
    org$example$Example$foo.get();
  if (resultFromCache.$eq$eq(null))
    {
      org$example$Example$foo$$tracer.calculationStart();
      val org$example$Example$foo$computedValue = try {
        "Foo"
      } finally org$example$Example$foo$$tracer.calculationEnd();
      assert(org$example$Example$foo$computedValue.$bang$eq(null), "Cached function should never return null");
      org$example$Example$foo$map.put(x, new _root_.com.intellij.util.SofterReference(org$example$Example$foo$computedValue));
      org$example$Example$foo$computedValue
    }
  else
    resultFromCache
};
()
*/
}
